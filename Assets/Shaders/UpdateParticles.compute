#pragma kernel SolveCollisions
#pragma kernel ApplyGravity

struct Particle {
    float2 position;
    float2 velocity;
};
struct Obstacle {
    int type;
    float2 position;
    float2 size;
    float2x2 rotation;
};

StructuredBuffer<Particle> _ReadParticles;
RWStructuredBuffer<Particle> _WriteParticles;
StructuredBuffer<Obstacle> _Obstacles;

float deltaTime;
float radius;
float dampingFactor;
float penetrationFactor;
float2 bounds;
int obstacleCount;

[numthreads(64, 1, 1)]
void SolveCollisions (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _ReadParticles.Length) return;

    Particle p = _ReadParticles[i];

    // Collision with bounds
    if (p.position.x < -bounds.x + radius) {
        p.position.x = -bounds.x + radius;
        p.velocity.x = -p.velocity.x * dampingFactor;
    }
    if (p.position.x > bounds.x - radius) {
        p.position.x = bounds.x - radius;
        p.velocity.x = -p.velocity.x * dampingFactor;
    }
    if (p.position.y < -bounds.y + radius) {
        p.position.y = -bounds.y + radius;
        p.velocity.y = -p.velocity.y * dampingFactor;
    }
    if (p.position.y > bounds.y - radius) {
        p.position.y = bounds.y - radius;
        p.velocity.y = -p.velocity.y * dampingFactor;
    }

    // Collision with other particles
    for (uint j = 0; j < _ReadParticles.Length; j++) {
        if (i == j) continue;

        Particle q = _ReadParticles[j];

        float2 delta = p.position - q.position;
        float dist = length(delta);
        float minDist = 2.0 * radius;

        if (dist < minDist && dist > 0.0001) {
            float2 normal = delta / dist;
            float2 relVel = p.velocity - q.velocity;

            // Only resolve if particles are moving toward each other
            if (dot(relVel, normal) < 0) {
                float2 impulse = normal * dot(-relVel, normal) / 2.0;
                p.velocity += impulse;

                // Damping only the normal component of the velocity
                float2 normalVel = dot(p.velocity, normal) * normal;
                float2 tangentialVel = p.velocity - normalVel;
                normalVel *= dampingFactor;
                p.velocity = normalVel + tangentialVel;
                
            }
            // Separation
            float penetration = minDist - dist;
            p.position += penetrationFactor * normal * penetration;
        }
    }

    // Collision with obstacles
    for (int k = 0; k < obstacleCount; k++) {
        Obstacle obs = _Obstacles[k];

        if (obs.type == 0) {
            // Circle obstacle
            float2 delta = p.position - obs.position;
            float dist = length(delta);
            float combinedRadius = radius + obs.size.x;

            if (dist < combinedRadius && dist > 0.001) {
                float2 normal = delta / dist;
                float penetration = combinedRadius - dist;
                p.position += normal * penetration;
                p.velocity -= dot(p.velocity, normal) * normal;
                p.velocity *= dampingFactor;
            }
        }
        else if (obs.type == 1) {
            // Rectangle obstacle

            // Translate into obstacle local space
            float2 rel = p.position - obs.position;

            // Rotate into local (object) space using transpose
            float2x2 rotT = float2x2(
                obs.rotation[0].x, obs.rotation[1].x,
                obs.rotation[0].y, obs.rotation[1].y
            );

            float2 localPos = mul(rotT, rel);

            // Closest point in box
            float2 clamped = clamp(localPos, -obs.size, obs.size);

            float2 localDelta = localPos - clamped;
            float dist = length(localDelta);

            if (dist < radius && dist > 0.001) {
                float2 normalLocal = localDelta / dist;

                // Rotate normal back to world
                float2 normalWorld = mul(obs.rotation, normalLocal);

                float penetration = radius - dist;
                p.position += normalWorld * penetration;
                p.velocity -= dot(p.velocity, normalWorld) * normalWorld;
                p.velocity *= dampingFactor;
            }
        }
    }
    
    _WriteParticles[i] = p;
}


float2 gravity;

[numthreads(64, 1, 1)]
void ApplyGravity (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _ReadParticles.Length) return;

    Particle p = _ReadParticles[i];

    p.velocity += gravity * deltaTime;
    p.position += p.velocity * deltaTime;

    _WriteParticles[i] = p;
}
